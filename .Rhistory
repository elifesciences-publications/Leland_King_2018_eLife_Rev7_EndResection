filename = str_c(fig_save_dir,this_fig,"_subpixel_focus_intensity.pdf"),
device = cairo_pdf(),
width = 40, height = 9, units = "cm")
#dev.off()
}
# Beehive plots of resection rate (Fig 1F, 2C, 3A, 3s2B) ------------------------
# calculate all resection rates from raw datausing helper function
df.res.rates <- find_res_rates(df)
# Figure 1F: beehive plot of resection rate for WT, exo1, crb2
tmp.genotypes <- c("wt","exo1","crb2")
# fancy way of breaking this up into two steps so we can get "binned" versions
# of the red median crossbars that align perfectly with the dots!
tmp.g <-
df.res.rates %>% filter(f.is_usable, res.exact, is.na(c.notes) | !str_detect(c.notes, "sick|dead"),
e.genotype %in% tmp.genotypes) %>%
mutate(e.genotype = factor( e.genotype, levels = tmp.genotypes)) %>%
ggplot(aes(x=e.genotype,y=res.rate, group=e.genotype)) +
geom_dotplot(binaxis = "y", stackdir = "center",
method="histodot",binwidth=0.8, dotsize=.9)
tmp.g +
stat_summary(data=layer_data(tmp.g) %>% mutate(e.genotype=factor(x,levels=1:(length(tmp.genotypes)-1),labels=tmp.genotypes[-2])),
aes(x = e.genotype, y = y),
geom="crossbar", fun.data=crossbar_fun, fun.args=c(bar_width=.75),
color=NA,fill='red',size=0.8,width=1.2,alpha=0.5) +
scale_x_discrete(name="", labels=gg$genotype.labels, drop=FALSE) +
scale_y_continuous(name="Resection rate (kb/hr)") +
gg$my.theme + gg$rotate.x.lab +
theme(panel.background = element_blank(),
plot.background = element_blank())
ggsave(filename = str_c(fig_save_dir,"Figure1F_res_rate_wt_exo1_crb2.pdf"),
device = cairo_pdf(),
scale = 1, width = 11, height = 14, units = "cm")
# Figure 2C: beehive plot of resection rate for WT, exo1, crb2
tmp.genotypes <- c("wt","rev7", "crb2","rev3")
# fancy way of breaking this up into two steps so we can get "binned" versions
# of the red median crossbars that align perfectly with the dots!
tmp.g <-
df.res.rates %>% filter(f.is_usable, res.exact, is.na(c.notes) | !str_detect(c.notes, "sick|dead"),
e.genotype %in% tmp.genotypes) %>%
mutate(e.genotype = factor( e.genotype, levels = tmp.genotypes)) %>%
ggplot(aes(x=e.genotype,y=res.rate, group=e.genotype)) +
geom_dotplot(binaxis = "y", stackdir = "center",
method="histodot",binwidth=0.8, dotsize=.9)
tmp.g +
stat_summary(data=layer_data(tmp.g) %>% mutate(e.genotype=factor(x,levels=1:(length(tmp.genotypes)),labels=tmp.genotypes)),
aes(x = e.genotype, y = y),
geom="crossbar", fun.data=crossbar_fun, fun.args=c(bar_width=.75),
color=NA,fill='red',size=0.8,width=0.95,alpha=0.5) +
scale_x_discrete(name="", labels=gg$genotype.labels, drop=FALSE) +
scale_y_continuous(name="Resection rate (kb/hr)") +
gg$my.theme + gg$rotate.x.lab +
theme(panel.background = element_blank(),
plot.background = element_blank())
ggsave(filename = str_c(fig_save_dir,"Figure2C_res_rate_wt_rev7_crb2_rev3.pdf"),
device = cairo_pdf(),
scale = 1, width = 13, height = 14, units = "cm")
# Figure 3A: beehive plot of resection rate, epistasis for all genotypes
tmp.genotypes <- c("wt","exo1","rqh1","crb2","crb2exo1","crb2rqh1","rev7","rev7exo1","rev7rqh1","rev7crb2")
# fancy way of breaking this up into two steps so we can get "binned" versions
# of the red median crossbars that match perfectly!
tmp.g <-
df.res.rates %>% filter(f.is_usable, res.exact, is.na(c.notes) | !str_detect(c.notes, "sick|dead"),
e.genotype %in% tmp.genotypes) %>%
mutate(e.genotype = factor( e.genotype, levels = tmp.genotypes)) %>%
ggplot(aes(x=e.genotype,y=res.rate, group=e.genotype)) +
geom_dotplot(binaxis = "y", stackdir = "center",
method="histodot",binwidth=0.8, dotsize=.9)
tmp.g +
stat_summary(data=layer_data(tmp.g) %>% mutate(e.genotype=factor(x,levels=1:(length(tmp.genotypes)-1),labels=tmp.genotypes[-2])),
aes(x = e.genotype, y = y),
geom="crossbar", fun.data=crossbar_fun, fun.args=c(bar_width=.75),
color=NA,fill='red',size=0.8,width=.8,alpha=0.5) +
scale_x_discrete(name="", labels=gg$genotype.labels, drop=FALSE) +
scale_y_continuous(name="Resection rate (kb/hr)") +
gg$my.theme + gg$rotate.x.lab +
theme(panel.background = element_blank(),
plot.background = element_blank())
ggsave(filename = str_c(fig_save_dir,"Figure3A_res_rate_all_genotypes_epistasis.pdf"),
device = cairo_pdf(),
scale = 1, width = 29, height = 16, units = "cm")
# Figure 3s2B: beehive plot of resection DURATION (flipped axis) for all genotypes
# including both exactly determined durations (black) and non-exactly determined (red)
tmp.genotypes <- c("wt","exo1","rqh1","crb2","crb2exo1","crb2rqh1","rev7","rev7exo1","rev7rqh1","rev7crb2","rev3")
tmp.g <- df.res.rates %>% filter(f.is_usable, is.na(c.notes) | !str_detect(c.notes, "sick|dead"),
e.genotype %in% tmp.genotypes,
!(e.genotype == "exo1" & res.exact)) %>%
# leave an empty space to write in "exo1":
mutate(e.genotype = factor( e.genotype, levels = tmp.genotypes ),
res.durtn = (res.end-res.start) * (m.t_int/60)) %>%
ggplot(aes(x=e.genotype,y=res.durtn,fill=!res.exact,color=!res.exact)) +
geom_dotplot(binaxis = "y", stackdir = "center",
method="histodot", binwidth=10, dotsize=.7,
position=position_dodge(width = 0.8)) +
scale_x_discrete(name="", labels=gg$genotype.labels, drop=FALSE) +
scale_y_continuous(name="Resection duration (min)") +
scale_fill_manual(values=c("black","red"), labels=c("exact duration","minimum possible duration")) +
scale_color_manual(values=c("black","red"), labels=c("exact duration","minimum possible duration")) +
gg$my.theme + gg$rotate.x.lab +
theme(panel.background = element_blank(),
plot.background = element_blank(),
legend.position = c(.75,.9),
legend.direction = "vertical",
legend.title = element_blank(),
legend.margin = margin(0,8,6,4),
legend.text = element_text(size = rel(0.8)),
legend.background = element_rect(color = "black"))
ggsave(tmp.g,
filename = str_c(fig_save_dir,"Figure3s2B_res_DURATION_all_genotypes_plus_non-exact.pdf"),
device = cairo_pdf(),
scale = 1, width = 31, height = 14, units = "cm")
# make the 2nd y-axis (resection rate)
decm.places <- 2
dur.to.rate <- function(x) format(round(kb.to.LacO.end/(x/60),decm.places),nsmall=decm.places)
rate.to.dur <- function(x) round((kb.to.LacO.end/x)*60,6)
tmp.color <- "gray40"
tmp.g2 <-
tmp.g +
scale_y_continuous(name="Resection rate (kb/hr)",
breaks=rate.to.dur(as.double(dur.to.rate(c(100,200,300,400)))),
labels=dur.to.rate) +
theme(text = element_text(color=tmp.color),
axis.line = element_line(color=tmp.color),
axis.ticks = element_line(color=tmp.color),
axis.text = element_text(color=tmp.color),
rect = element_rect(color=tmp.color))
ggsave(tmp.g2,
filename = str_c(fig_save_dir,"Figure3s2B_second_y-axis_showing_rate.pdf"),
device = cairo_pdf(),
scale = 1, width = 27, height = 14, units = "cm")
# qPCR with primers across the HOcs (Fig 1sA, 2E) -----------------------------------
# Fig 1sA: ONLY plot the wt and exo data
hocs.qpcr %>%
gather(key="genotype",value="pct.cut",wt,rev7,exo1) %>%
filter(genotype %in% c("wt","exo1")) %>%
mutate(genotype = factor(genotype,levels = c("wt","exo1"))) %>%
ggplot(aes(x=genotype, y=pct.cut)) +
stat_summary(fun.y = mean, geom="bar", color="black", fill="grey") +
stat_summary(fun.ymin = function(x) mean(x) - ((sd(x)/sqrt(length(x))) * qnorm(0.975)),
fun.ymax = function(x) mean(x) + ((sd(x)/sqrt(length(x))) * qnorm(0.975)),
geom="errorbar", width = 0.2, size = 1) +
scale_y_continuous(name = "Percent loss of qPCR\nproduct across the HOcs", labels = function(x) str_c(x,"%")) +
scale_x_discrete(name="", labels = gg$genotype.labels) +
gg$my.theme +
theme(plot.title = element_text(hjust=0.5))
ggsave(filename = str_c(fig_save_dir,"Figure1s3A_HOcsQPCR_WTexo1Only.pdf"),
device = cairo_pdf(),
scale = 1, width = 8, height = 11, units = "cm")
# stats for drawing in on this figure:
hocs.qpcr %>%
gather(key="genotype",value="pct.cut",wt,rev7,exo1) %>%
mutate(genotype = factor(genotype,levels = c("wt","rev7","exo1"))) %>%
{pairwise.t.test(.$pct.cut, .$genotype,
p.adjust.method = "none",
pool.sd = FALSE,
paired = FALSE,
alternative = "two.sided")}
# Fig 2E: ONLY plot the wt and rev7 data
hocs.qpcr %>%
gather(key="genotype",value="pct.cut",wt,rev7,exo1) %>%
filter(genotype %in% c("wt","rev7")) %>%
mutate(genotype = factor(genotype,levels = c("wt","rev7"))) %>%
ggplot(aes(x=genotype, y=pct.cut)) +
stat_summary(fun.y = mean, geom="bar", color="black", fill="grey") +
stat_summary(fun.ymin = function(x) mean(x) - ((sd(x)/sqrt(length(x))) * qnorm(0.975)),
fun.ymax = function(x) mean(x) + ((sd(x)/sqrt(length(x))) * qnorm(0.975)),
geom="errorbar", width = 0.2, size = 1) +
scale_y_continuous(name = "Percent loss of qPCR\nproduct across the HOcs", labels = function(x) str_c(x,"%")) +
scale_x_discrete(name="", labels = gg$genotype.labels) +
gg$my.theme +
theme(plot.title = element_text(hjust=0.5))
ggsave(filename = str_c(fig_save_dir,"Figure2E_HOcsQPCR_WTrev7Only.pdf"),
device = cairo_pdf(),
scale = 1, width = 8, height = 11, units = "cm")
# stats for drawing in on this figure:
hocs.qpcr %>%
gather(key="genotype",value="pct.cut",wt,rev7,exo1) %>%
mutate(genotype = factor(genotype,levels = c("wt","rev7","exo1"))) %>%
{pairwise.t.test(.$pct.cut, .$genotype,
p.adjust.method = "none",
pool.sd = FALSE,
paired = FALSE,
alternative = "two.sided")}
# Combined plot: qPCR @ 168nt and %cells w/ Rad52 foci (Fig 1s3C) --------
# fit lines using lm() to find y.intercept, slope, r.squared, adj.r.squared,
# and qpcr.effic for each standard curve
# for this particular exp, I fit separate std curves for each timepoint (mostly
# these curvues all look the same though)
qp_old$lin.fits <-
qp_old$summary %>%
filter(is.std) %>%
group_by(plate,time) %>% # these are all the col variables that distinguish the std curves.
do(fit = lm(Cq ~ log(conc), data = .) ) %>%  # fit a line to each std curve using lm()
# now this gets ugly, but basically this is pulling out the y.intercept, slope, and R^2 values
# by using both the tidy() and glance() functions from broom, and then combining them
# together with a left_join
{ left_join(
tidy(.,fit) %>%   # tidy pulls out the slope and y.intercept, but we have to use spread() to make them separate columns
select(plate,time,term,estimate) %>%
spread(term,estimate) %>% rename(y.intercept=`(Intercept)`, slope=`log(conc)`),
glance(.,fit) %>% # glance pulls out the r.sqrd values
select(plate,time,r.squared, adj.r.squared)
)
} %>%
ungroup() %>%
mutate(  qpcr.effic = exp(-1/slope) - 1  ) # qPCR efficiency = e^(-1/slope) - 1
# Use linear fits to calculate concentration (calc.conc) from Cq:
qp_old$summary <-
left_join(qp_old$summary,
qp_old$lin.fits) %>%
select(-r.squared,-adj.r.squared,-qpcr.effic) %>% # only keep the added columns for y.intercept and slope
mutate(calc.conc = case_when(
.$is.empty  ~ NA_real_, # empty wells have a calc.conc of NA
.$is.std    ~ NA_real_, # std curve wells have a calc.conc of NA
is.na(.$Cq) ~ 0,        # all other wells with Cq=NA have a calc.conc of 0
TRUE        ~ exp( (.$Cq-.$y.intercept)/.$slope) )) # this is the formula to convert from Cq to calc.conc
# outlier wells (see extra plots for all triplicate measures ... F06 and F07 are
# outliers, likely because I pipetted the DNA that should have gone in F06 into
# F07 by mistake, giving one well 2x the DNA and one well ~0 DNA)
tmp.outlierwells <- c("F06","F07")
# Now do the WT %rad52 loading over time
# This helper function extracts only certin cell cycles that are valid for % Rad52 analysis
# (same as % Rad52 bar plots below, require at least 100 min of usable movie after nuc birth)
df.rad52.valid <- find_pct_rad52_valid_cells(df, min.time = 100)
# This helper fcn takes these valid cell cycles and bins various events, like Rad52 loading
# and lacO dissaperance
# bin.max is the latest usable timepoint across all movies, in minutes:
bin.min <- 0 # minutes
bin.max <- df.rad52.valid %>% mutate(max = (f.last_good_frame-1)*m.t_int + e.t_start) %>% {max(.$max)/60} # minutes
bin.width <- 8 # minutes
rad52.cumulative.counts <- find_cdf_like_rad52_cell_counts(df.rad52.valid, bin.width, bin.min, bin.max)
# combined qPCR AND Rad52% together with two y-axes:
tmp.qp.data <-
qp_old$summary %>%
filter(!is.empty, !is.noDNA, !is.std, primers %in% c("-168bps","Ncb2"), !(well %in% tmp.outlierwells)) %>%
# replace "-168bps" with "m168" to make variable names easier to handle
mutate(primers = as.factor(  if_else(primers == "-168bps","m168",as.character(primers))  )) %>%
select(strain,DNA,time,conc,primers,digest,rep,calc.conc) %>%
# find % resected for rep 1, 2, and 3 ... then get error bars across reps (some are NA bc of tmp.outlierwells)
unite(pcr.cond,primers,digest,sep=".") %>%
spread(pcr.cond,calc.conc) %>%
mutate(pct.resected    = (m168.ApoI/m168.HincII) - (Ncb2.ApoI/m168.HincII)) %>%
group_by(time) %>%
summarize(pct.resected.ave = mean(pct.resected,na.rm=T),
pct.resected.n   = sum(!is.na(pct.resected)),
pct.resected.se = sd(pct.resected,na.rm=T) / sqrt(pct.resected.n)) %>%
mutate(time = if_else(time==110,120,time))
tmp.rad52.cum.data <-
rad52.cumulative.counts %>%
filter(e.genotype == "wt", event.type == "cmpct_cyc_with_Rad52")
tmp.color.y.right <- "brown4"
tmp.g <- ggplot() +
geom_bar(data=tmp.qp.data,
aes(x=time, y=pct.resected.ave),
width=46, stat="identity", color="black", fill="gray65", size=0.6) +
geom_errorbar(data=tmp.qp.data,
aes(x=time, ymin=pct.resected.ave-pct.resected.se, ymax=pct.resected.ave+pct.resected.se),
size = 1, width = 20) +
geom_step(data=tmp.rad52.cum.data,
aes(x=bin.right, y=g.cm.value),
size=1.2, color=tmp.color.y.right) +
scale_x_continuous(name="Time after HO induction (min)",limits=c(-23,240),breaks=c(0,60,120,180,240,300)) +
scale_y_continuous(name="ApoI protection\n(168 nt from HOcs)",limits=c(0,.17),labels=scales::percent,
sec.axis = sec_axis(~., name="Cumulative cell cycles\nwith Rad52 foci",labels=scales::percent)) +
gg$my.theme +
theme(axis.title.y.right=element_text(color=tmp.color.y.right),
axis.text.y.right=element_text(color=tmp.color.y.right))
tmp.g
# use grid graphics to change just the color of the right y-axis!
tmp.grob <- ggplotGrob(tmp.g)
tmp.grob$grobs[[grep("axis-r",tmp.grob$layout$name)]]$children[[1]]$gp$col <- tmp.color.y.right
tmp.grob$grobs[[grep("axis-r",tmp.grob$layout$name)]]$children[[2]][[1]][[1]]$gp$col <- tmp.color.y.right
grid.newpage()
grid.draw(tmp.grob)
ggsave(filename = str_c(fig_save_dir,"Figure1s3C_WT_qPCR_and_PctRad52_overlaid.pdf"),
plot = grid.draw(tmp.grob),
device = cairo_pdf(),
scale = 1, width = 16, height = 11.5, units = "cm")
# qPCR showing resection rate on LacO and non-LacO side of break (Fig1s3H) --------
tmp.to.plot <-
qp$summ.calc.conc %>%
# remove excluded values, and put ApoI and HincII calculated concentrations into two different cols:
filter(is.expWell, !is.excluded) %>%
select(date, plate, strain, time, digest, primers, rep, calc.conc) %>%
spread(digest, calc.conc) %>%
# calculate means for each (ApoI, HincII), then get pct.undigested=ApoI/HincII, using error propagation!
group_by(date, plate, strain, time, primers) %>%
summarize(ave.ApoI = mean(ApoI,na.rm=T), n.ApoI = sum(!is.na(ApoI)), se.ApoI = sd(ApoI,na.rm=T) / sqrt(n.ApoI),
ave.HincII = mean(HincII,na.rm=T), n.HincII = sum(!is.na(HincII)), se.HincII = sd(HincII,na.rm=T) / sqrt(n.HincII),
ave.pct.undigested = ave.ApoI/ave.HincII,
se.pct.undigested = ave.pct.undigested * sqrt( (se.ApoI/ave.ApoI)^2 + (se.HincII/ave.HincII)^2 )) %>%
# find the proper Ncb2 controls to use for each measurment
group_by(date, plate, strain, time) %>%
mutate(ave.ncb2.digest.eff = first( if_else(primers == "Ncb2_v1",ave.pct.undigested,NA_real_) ),
se.ncb2.digest.eff = first( if_else(primers == "Ncb2_v1",se.pct.undigested,NA_real_) )) %>%
filter(primers != "Ncb2_v1") %>% # get rid of all Ncb2 rows, we don't need them anymore!
# if there is not an Ncb2 control for a specific strain/primer combo, then use an average from the plate instead (error prop. is wonky here ...)
ungroup() %>% group_by(date,plate) %>%
mutate(ave.ncb2.digest.eff = if_else(is.finite(ave.ncb2.digest.eff), ave.ncb2.digest.eff, mean(ave.ncb2.digest.eff, na.rm=TRUE)),
se.ncb2.digest.eff = if_else(is.finite(se.ncb2.digest.eff), se.ncb2.digest.eff, mean(se.ncb2.digest.eff, na.rm=TRUE))) %>%
# using Ncb2 digest efficiency, "background subtract" and use error propagation
ungroup() %>%
mutate(ave.pct.resection = ave.pct.undigested - ave.ncb2.digest.eff,
se.pct.resection = sqrt(se.pct.undigested^2 + se.ncb2.digest.eff^2))
# with 95% CIs for error bars:
tmp.to.plot %>%
filter(date == "2017_0727", strain == 2123) %>%
arrange(primers,time) %>%
ggplot(aes(x=time, color=primers,
y=ave.pct.resection, ymin=ave.pct.resection-se.pct.resection*qnorm(0.975), ymax=ave.pct.resection+se.pct.resection*qnorm(0.975))) +
geom_line(size = 1.25) + geom_point() +
geom_errorbar(size = 0.75, width = 10, color="black") +
scale_y_continuous(name="Percent Resected\n(undigested by ApoI)", labels=scales::percent) +
scale_x_continuous(name="Time after HO induction", breaks = seq(-360,360,120), labels = function(x) abs(x)) +
scale_color_gdocs(name="Distance from HOcs", labels=c("-168 bps","-14,253 bps","+13,150 bps")) +
gg$my.theme
ggsave(filename = str_c(fig_save_dir,"Figure1s3H_qPCR_equal_rates_LacOside_and_other_side.pdf"),
device = cairo_pdf(),
scale = 1, width = 20, height = 12.5, units = "cm")
# qPCR at 90min: wt, exo1, ctp1 (Fig 1s3I) --------------------------------
tmp.to.plot <-
qp$summ.calc.conc %>%
# remove excluded values, and put ApoI and HincII calculated concentrations into two different cols:
filter(is.expWell, !is.excluded) %>%
select(date, plate, strain, time, digest, primers, rep, calc.conc) %>%
spread(digest, calc.conc) %>%
# calculate means for each (ApoI, HincII), then get pct.undigested=ApoI/HincII, using error propagation!
group_by(date, plate, strain, time, primers) %>%
summarize(ave.ApoI = mean(ApoI,na.rm=T), n.ApoI = sum(!is.na(ApoI)), se.ApoI = sd(ApoI,na.rm=T) / sqrt(n.ApoI),
ave.HincII = mean(HincII,na.rm=T), n.HincII = sum(!is.na(HincII)), se.HincII = sd(HincII,na.rm=T) / sqrt(n.HincII),
ave.pct.undigested = ave.ApoI/ave.HincII,
se.pct.undigested = ave.pct.undigested * sqrt( (se.ApoI/ave.ApoI)^2 + (se.HincII/ave.HincII)^2 )) %>%
# find the proper Ncb2 controls to use for each measurment
group_by(date, plate, strain, time) %>%
mutate(ave.ncb2.digest.eff = first( if_else(primers == "Ncb2_v1",ave.pct.undigested,NA_real_) ),
se.ncb2.digest.eff = first( if_else(primers == "Ncb2_v1",se.pct.undigested,NA_real_) )) %>%
filter(primers != "Ncb2_v1") %>% # get rid of all Ncb2 rows, we don't need them anymore!
# if there is not an Ncb2 control for a specific strain/primer combo, then use an average from the plate instead (error prop. is wonky here ...)
ungroup() %>% group_by(date,plate) %>%
mutate(ave.ncb2.digest.eff = if_else(is.finite(ave.ncb2.digest.eff), ave.ncb2.digest.eff, mean(ave.ncb2.digest.eff, na.rm=TRUE)),
se.ncb2.digest.eff = if_else(is.finite(se.ncb2.digest.eff), se.ncb2.digest.eff, mean(se.ncb2.digest.eff, na.rm=TRUE))) %>%
# using Ncb2 digest efficiency, "background subtract" and use error propagation
ungroup() %>%
mutate(ave.pct.resection = ave.pct.undigested - ave.ncb2.digest.eff,
se.pct.resection = sqrt(se.pct.undigested^2 + se.ncb2.digest.eff^2))
tmp.dist.factor.levels <- c("m300","m3023") # "m1556" ?
tmp.dist.factor.labels <- c("-300 bps", "-3,023 bps")
tmp.geno.factor.levels <- c(2123,1914,2477)
tmp.geno.factor.labels <- c("paste('WT')","paste(italic('exo1'),Delta)","paste(italic('ctp1'),Delta)")
# tmp.to.plot is calculated %resection from above "New 1E"
tmp.to.plot %>%
filter(strain %in% tmp.geno.factor.levels,
primers %in% tmp.dist.factor.levels,
time %in% c(0,90)) %>%
arrange(strain,primers,time) %>%
mutate(strain = factor(strain, tmp.geno.factor.levels, tmp.geno.factor.labels),
primers = factor(primers, tmp.dist.factor.levels, tmp.dist.factor.labels)) %>%
# normalize to set 0min %resection to zero:
# this is dangerous bc it remove the exp data/plate info ...
select(strain,time,primers,  ave.pct.resection,se.pct.resection) %>%
gather(key = "ave_or_se", value = "value", ave.pct.resection, se.pct.resection) %>%
unite(new_key,ave_or_se,time,sep="_") %>%
spread(new_key,value) %>%
# now calculate the new normalized pct resection at 90 min:
mutate(norm.90min.pct.resection = ave.pct.resection_90 - ave.pct.resection_0,
norm.90min.se = sqrt( se.pct.resection_0^2 + se.pct.resection_90^2 )) %>%
# plot
ggplot(aes(x=primers,
y=norm.90min.pct.resection, ymin=norm.90min.pct.resection-norm.90min.se*qnorm(0.975), ymax=norm.90min.pct.resection+norm.90min.se*qnorm(0.975))) +
geom_bar(stat="identity",position="dodge",color="black", fill="grey") +
geom_errorbar(size = 1, width = 0.5) +
geom_hline(yintercept = 0) +
facet_grid(.~strain, scales="free", space="free", labeller = label_parsed) +
scale_y_continuous(name="Percent Resected\n(normalized to T=0min)", labels=scales::percent) +
scale_x_discrete(name="Distance from HOcs") +
gg$my.theme +
gg$rotate.x.lab +
theme(strip.text = element_text(size = 20, face = "bold"))
ggsave(filename = str_c(fig_save_dir,"Figure1s3I_qPCR_wt_exo1_ctp1_90normalized.pdf"),
device = cairo_pdf(),
scale = 1, width = 12, height = 13, units = "cm")
# Pct Cells with Rad52 foci 180min (Fig1s3J) ------------------------------
# valid cells based on all critera above using this helper function
df.rad52.valid <- find_pct_rad52_valid_cells(df, min.time = 100)
# use this helper function to calculate the means and error bars for % Rad52 on
# both a per-experiment (biological replicate) basis (columns starting with "e.")
# as well as on a per-genotype basis ("g." columns). Includes weighted, pooled,
# and simple averaged means and variance.
min.cells.cutoff <- 35
pct.rad52.by.run <- calc_rad52_pcts(df.rad52.valid, min.cells.cutoff = min.cells.cutoff)
# genotypes we are interested in for this figure:
tmp.genotypes <- c("wt","exo1")
# All data pooled across biological replicates, 95% CI error bars:
pct.rad52.by.run %>%
filter(e.genotype %in% tmp.genotypes) %>%
ggplot(aes(x=e.genotype, y=g.pooled_mean, ymin=g.pooled_mean-g.pooled_ci95, ymax=g.pooled_mean+g.pooled_ci95)) +
geom_bar(stat="unique",position="identity") +
geom_errorbar(size = 1, width = 0.35) +
scale_x_discrete(name="",labels=gg$genotype.labels,drop=TRUE) +
scale_y_continuous(name="Cell cycles w/ Rad52 foci",limits=c(0,.2),labels=scales::percent) +
gg$my.theme + gg$rotate.x.lab
ggsave(filename = str_c(fig_save_dir,"Figure1s3J_Rad52_foci_formation_WT_exo1.pdf"),
device = cairo_pdf(),
scale = 1, width = 7, height = 12, units = "cm")
# qPCR comparison of WT and rev (Fig 2D) ----------------------------------
tmp.to.plot <-
qp$summ.calc.conc %>%
# remove excluded values, and put ApoI and HincII calculated concentrations into two different cols:
filter(is.expWell, !is.excluded) %>%
select(date, plate, strain, time, digest, primers, rep, calc.conc) %>%
spread(digest, calc.conc) %>%
# calculate means for each (ApoI, HincII), then get pct.undigested=ApoI/HincII, using error propagation!
group_by(date, plate, strain, time, primers) %>%
summarize(ave.ApoI = mean(ApoI,na.rm=T), n.ApoI = sum(!is.na(ApoI)), se.ApoI = sd(ApoI,na.rm=T) / sqrt(n.ApoI),
ave.HincII = mean(HincII,na.rm=T), n.HincII = sum(!is.na(HincII)), se.HincII = sd(HincII,na.rm=T) / sqrt(n.HincII),
ave.pct.undigested = ave.ApoI/ave.HincII,
se.pct.undigested = ave.pct.undigested * sqrt( (se.ApoI/ave.ApoI)^2 + (se.HincII/ave.HincII)^2 )) %>%
# find the proper Ncb2 controls to use for each measurment
group_by(date, plate, strain, time) %>%
mutate(ave.ncb2.digest.eff = first( if_else(primers == "Ncb2_v1",ave.pct.undigested,NA_real_) ),
se.ncb2.digest.eff = first( if_else(primers == "Ncb2_v1",se.pct.undigested,NA_real_) )) %>%
filter(primers != "Ncb2_v1") %>% # get rid of all Ncb2 rows, we don't need them anymore!
# if there is not an Ncb2 control for a specific strain/primer combo, then use an average from the plate instead (error prop. is wonky here ...)
ungroup() %>% group_by(date,plate) %>%
mutate(ave.ncb2.digest.eff = if_else(is.finite(ave.ncb2.digest.eff), ave.ncb2.digest.eff, mean(ave.ncb2.digest.eff, na.rm=TRUE)),
se.ncb2.digest.eff = if_else(is.finite(se.ncb2.digest.eff), se.ncb2.digest.eff, mean(se.ncb2.digest.eff, na.rm=TRUE))) %>%
# using Ncb2 digest efficiency, "background subtract" and use error propagation
ungroup() %>%
mutate(ave.pct.resection = ave.pct.undigested - ave.ncb2.digest.eff,
se.pct.resection = sqrt(se.pct.undigested^2 + se.ncb2.digest.eff^2))
tmp.dist.factor.levels <- c("m300","m3023","p13150") # "m1556" ?
tmp.dist.factor.labels <- c("-300 bps", "-3,023 bps", "+13,150 bps")
tmp.geno.factor.levels <- c(2123,2149)
tmp.geno.factor.labels <- c("wt","rev7")
tmp.90min.from.Fig4C <-
tmp.to.plot %>%
filter(!(date == "2017_0807" & strain == 2149),
strain %in% tmp.geno.factor.levels,
primers %in% c("m300","m3023"),
time %in% c(0,90)) %>%
arrange(strain,primers,time) %>%
mutate(strain = factor(strain, tmp.geno.factor.levels, tmp.geno.factor.labels),
primers = factor(primers, tmp.dist.factor.levels, tmp.dist.factor.labels)) %>%
# normalize to set 0min %resection to zero:
# this is dangerous bc it remove the exp data/plate info ...
select(strain,time,primers,  ave.pct.resection,se.pct.resection) %>%
gather(key = "ave_or_se", value = "value", ave.pct.resection, se.pct.resection) %>%
unite(new_key,ave_or_se,time,sep="_") %>%
spread(new_key,value) %>%
# now calculate the new normalized pct resection at 90 min:
mutate(time.facet.label = "090min",
norm.pct.resection = ave.pct.resection_90 - ave.pct.resection_0,
norm.se = sqrt( se.pct.resection_0^2 + se.pct.resection_90^2 ))
tmp.180min.from.Fig2C <-
tmp.to.plot %>%
filter(date == "2017_0807", strain %in% c(2123,2149), primers == "p13150") %>%
arrange(strain,primers,time) %>%
mutate(strain = factor(strain, tmp.geno.factor.levels, tmp.geno.factor.labels),
primers = factor(primers, tmp.dist.factor.levels, tmp.dist.factor.labels)) %>%
# normalize to set 0min %resection to zero:
# this is dangerous bc it remove the exp data/plate info ...
select(strain,time,primers,  ave.pct.resection,se.pct.resection) %>%
gather(key = "ave_or_se", value = "value", ave.pct.resection, se.pct.resection) %>%
unite(new_key,ave_or_se,time,sep="_") %>%
spread(new_key,value) %>%
# now calculate the new normalized pct resection at 90 min:
mutate(time.facet.label = "180min",
norm.pct.resection = ave.pct.resection_180 - ave.pct.resection_0,
norm.se = sqrt( se.pct.resection_0^2 + se.pct.resection_180^2 ))
tmp.comb.to.plot <-
bind_rows(tmp.90min.from.Fig4C  %>% select(-ave.pct.resection_0,-ave.pct.resection_90,-se.pct.resection_0,-se.pct.resection_90),
tmp.180min.from.Fig2C %>% select(-ave.pct.resection_0,-ave.pct.resection_180,se.pct.resection_0,-se.pct.resection_180))
tmp.comb.to.plot %>%
mutate(facet.var = interaction(primers,time.facet.label)) %>%
ggplot(aes(x=strain, fill = strain,
y=norm.pct.resection, ymin=norm.pct.resection-norm.se*qnorm(0.975), ymax=norm.pct.resection+norm.se*qnorm(0.975))) +
geom_bar(stat="identity",position="dodge",color="black") +
geom_errorbar(size = 1, width = 0.5) +
geom_hline(yintercept = 0) +
facet_grid(.~facet.var, scales="free", space="free") +
scale_y_continuous(name="Percent Resected\n(normalized to T=0min)", labels=scales::percent) +
scale_x_discrete(name="") +
scale_fill_gdocs(name="", labels=c("WT",expression(paste(italic("rev7"),Delta)))) +
coord_cartesian(xlim = c(0.25,2.75), expand = FALSE) +
gg$my.theme +
theme(axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
strip.background = element_blank(),
strip.text = element_blank())
ggsave(tmp.p,
filename = str_c(fig_save_dir,"Figure2D_qPCR_wt_and_rev7_comparison.pdf"),
device = cairo_pdf(),
scale = 1, width = 18, height = 12, units = "cm")
tmp.comb.to.plot %>%
mutate(facet.var = interaction(primers,time.facet.label)) %>%
ggplot(aes(x=strain, fill = strain,
y=norm.pct.resection, ymin=norm.pct.resection-norm.se*qnorm(0.975), ymax=norm.pct.resection+norm.se*qnorm(0.975))) +
geom_bar(stat="identity",position="dodge",color="black") +
geom_errorbar(size = 1, width = 0.5) +
geom_hline(yintercept = 0) +
facet_grid(.~facet.var, scales="free", space="free") +
scale_y_continuous(name="Percent Resected\n(normalized to T=0min)", labels=scales::percent) +
scale_x_discrete(name="") +
scale_fill_gdocs(name="", labels=c("WT",expression(paste(italic("rev7"),Delta)))) +
coord_cartesian(xlim = c(0.25,2.75), expand = FALSE) +
gg$my.theme +
theme(axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
strip.background = element_blank(),
strip.text = element_blank())
ggsave(filename = str_c(fig_save_dir,"Figure2D_qPCR_wt_and_rev7_comparison.pdf"),
device = cairo_pdf(),
scale = 1, width = 18, height = 12, units = "cm")
